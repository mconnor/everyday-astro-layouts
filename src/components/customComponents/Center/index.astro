---
type Props = {
    max?: string
    andText?: boolean
    gutters?: number
    intrinsic?: boolean
}

const {
    max = 'var(--measure)',
    andText = false,
    gutters = 0,
    intrinsic = false,
} = Astro.props
---

<center-l
    :max={max}
    :andText={andText}
    :gutters={gutters}
    :intrinsic={intrinsic}
>
    <div><slot /></div>
</center-l>

<script type="module">
    /**
     * @module center-l
     * @description
     * A custom element for centering a block-level element horizontally,
     * with a max-width value representing the typographic measure
     * @property {string} max=var(--measure) A CSS `max-width` value
     * @property {boolean} andText=false Center align the text too (`text-align: center`)
     * @property {boolean} gutters=0 The minimum space on either side of the content
     * @property {boolean} intrinsic=false Center child elements based on their content width
     */
    export default class Center extends HTMLElement {
        constructor() {
            super()

            // const centerTag = this.querySelector('div')
            const doc = document

            this.render = () => {
                const max = this.dataset.max
                const gutters = this.dataset.gutters
                const andText = this.dataset.andText
                const intrinsic = this.dataset.intrinsic

                this.i = `Center-${[max, andText, gutters, intrinsic].join('')}`
                this.dataset.i = this.i
                if (!doc.getElementById(this.i)) {
                    let styleEl = document.createElement('style')
                    styleEl.id = this.i
                    styleEl.innerHTML = `
          [data-i="${this.i}"] {
            max-width: ${max};
            ${
                gutters
                    ? `
            padding-inline-start: ${gutters};
            padding-inline-end: ${gutters};`
                    : ''
            }
            ${andText ? `text-align: center;` : ''}
            ${
                intrinsic
                    ? `
            display: flex;
            flex-direction: column;
            align-items: center;`
                    : ''
            }
          }
        `
                        .replace(/\s\s+/g, ' ')
                        .trim()
                    doc.head.appendChild(styleEl)
                }
            }
        }

        get max() {
            return this.getAttribute('max') || 'var(--measure)'
        }

        set max(val) {
            return this.setAttribute('max', val)
        }

        get andText() {
            return this.hasAttribute('andText')
        }

        set andText(val) {
            if (val) {
                return this.setAttribute('andText', '')
            } else {
                return this.removeAttribute('andText')
            }
        }

        get gutters() {
            return this.getAttribute('gutters') || null
        }

        set gutters(val) {
            return this.setAttribute('gutters', val)
        }

        get intrinsic() {
            return this.hasAttribute('intrinsic')
        }

        set intrinsic(val) {
            if (val) {
                return this.setAttribute('intrinsic', '')
            } else {
                return this.removeAttribute('intrinsic')
            }
        }

        static get observedAttributes() {
            return ['max', 'andText', 'gutters', 'intrinsic']
        }

        connectedCallback() {
            this.render()
        }

        attributeChangedCallback() {
            this.render()
        }
    }

    if ('customElements' in window) {
        customElements.define('center-l', Center)
    }
</script>

<style>
    center-l {
        display: block;
        box-sizing: content-box;
        margin-inline: auto;
        max-inline-size: var(--measure);
    }
</style>
